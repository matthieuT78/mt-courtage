// pages/api/receipts/confirm-manual.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { supabaseAdmin } from "../../../lib/supabaseAdmin";

type Json = Record<string, any>;

function base64(buf: Buffer) {
  return buf.toString("base64");
}

function parsePdfUrl(pdfUrl?: string | null) {
  if (!pdfUrl) return null;
  const [bucket, path] = String(pdfUrl).split(":");
  if (bucket !== "rent-receipts-pdfs" || !path) return null;
  return { bucket, path };
}

async function getAuthUserId(req: NextApiRequest): Promise<string | null> {
  // 1) internal secret bypass
  const internalSecret = String(req.headers["x-internal-secret"] || "");
  const expected = process.env.INTERNAL_API_SECRET || "";
  if (expected && internalSecret && internalSecret === expected) return "internal";

  // 2) Bearer token
  const auth = String(req.headers.authorization || "");
  const m = auth.match(/^Bearer\s+(.+)$/i);
  const token = m?.[1]?.trim();
  if (!token) return null;

  // Supabase: service role can validate access_token via Admin API
  const u = await supabaseAdmin.auth.getUser(token);
  if (u.error || !u.data?.user?.id) return null;
  return u.data.user.id;
}

async function sendEmailViaResend(params: {
  to: string;
  cc?: string | null;
  subject: string;
  html: string;
  attachments?: { filename: string; contentBase64: string }[];
}) {
  const apiKey = process.env.RESEND_API_KEY;
  const from = process.env.RESEND_FROM;

  if (!apiKey || !from) {
    return { ok: false, error: "Email non configuré (RESEND_API_KEY / RESEND_FROM manquants)." };
  }

  const payload: any = {
    from,
    to: params.to,
    subject: params.subject,
    html: params.html,
  };

  if (params.cc) payload.cc = params.cc;
  if (params.attachments?.length) payload.attachments = params.attachments;

  const r = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });

  const raw = await r.text();
  let json: any = null;
  try {
    json = raw ? JSON.parse(raw) : null;
  } catch {}

  if (!r.ok) return { ok: false, error: json?.message || raw || `Erreur Resend ${r.status}` };
  return { ok: true, id: json?.id || null };
}

export default async function handler(req: NextApiRequest, res: NextApiResponse<Json>) {
  try {
    if (req.method !== "POST") return res.status(405).json({ error: "Method not allowed" });
    if (!supabaseAdmin) return res.status(500).json({ error: "Supabase admin non configuré." });

    const callerUserId = await getAuthUserId(req);
    if (!callerUserId) return res.status(401).json({ error: "Non authentifié (Bearer token manquant/invalide)." });

    const body = (req.body || {}) as {
      userId?: string;
      receiptId?: string;
      landlordEmail?: string; // optionnel (fallback CC)
    };

    const userId = String(body.userId || "").trim();
    const receiptId = String(body.receiptId || "").trim();
    const landlordEmailFromBody = String(body.landlordEmail || "").trim() || null;

    if (!userId) return res.status(400).json({ error: "userId requis." });
    if (!receiptId) return res.status(400).json({ error: "receiptId requis." });

    // si pas internal, on force userId == auth user
    if (callerUserId !== "internal" && callerUserId !== userId) {
      return res.status(403).json({ error: "Accès refusé (user mismatch)." });
    }

    // 1) Load receipt
    const r0 = await supabaseAdmin.from("rent_receipts").select("*").eq("id", receiptId).single();
    if (r0.error || !r0.data) return res.status(404).json({ error: "Quittance introuvable." });
    const receipt: any = r0.data;

    // 2) Load lease, check owner
    const leaseRes = await supabaseAdmin.from("leases").select("*").eq("id", receipt.lease_id).single();
    if (leaseRes.error || !leaseRes.data) return res.status(404).json({ error: "Bail introuvable." });
    const lease: any = leaseRes.data;

    if (String(lease.user_id) !== userId) return res.status(403).json({ error: "Accès refusé." });

    // 3) Must have PDF (generated by cron)
    if (!receipt.pdf_url) {
      return res.status(400).json({
        error: "PDF manquant sur la quittance. Génère d’abord la quittance PDF (cron/force).",
      });
    }
    const parsed = parsePdfUrl(receipt.pdf_url);
    if (!parsed) {
      return res.status(400).json({ error: "pdf_url invalide (attendu rent-receipts-pdfs:<path>)" });
    }

    // 4) Idempotence check: if already confirmed/sent + payment exists + transaction exists => ok
    // (on est permissif: on va re-upsert ce qui manque)
    const alreadyPaid = !!receipt.payment_id || String(receipt.status || "").toLowerCase() === "sent";

    // 5) Upsert rent_payment (paid_at)
    let paymentId: string | null = receipt.payment_id || null;

    // try existing by (lease_id, period_start, period_end)
    const payExisting = await supabaseAdmin
      .from("rent_payments")
      .select("*")
      .eq("lease_id", receipt.lease_id)
      .eq("period_start", receipt.period_start)
      .eq("period_end", receipt.period_end)
      .maybeSingle();

    if (payExisting.data?.id) {
      paymentId = payExisting.data.id;

      const updPay = await supabaseAdmin
        .from("rent_payments")
        .update({
          paid_at: new Date().toISOString(),
          payment_method: lease.payment_method || null,
          source: "confirm_manual",
          rent_amount: receipt.rent_amount,
          charges_amount: receipt.charges_amount,
          total_amount: receipt.total_amount,
          updated_at: new Date().toISOString(),
        })
        .eq("id", paymentId);

      if (updPay.error) return res.status(500).json({ error: `Update paiement échoué: ${updPay.error.message}` });
    } else {
      const insPay = await supabaseAdmin
        .from("rent_payments")
        .insert({
          lease_id: receipt.lease_id,
          period_start: receipt.period_start,
          period_end: receipt.period_end,
          rent_amount: receipt.rent_amount,
          charges_amount: receipt.charges_amount,
          total_amount: receipt.total_amount,
          due_date: receipt.period_start, // optionnel
          paid_at: new Date().toISOString(),
          payment_method: lease.payment_method || null,
          source: "confirm_manual",
        })
        .select("id")
        .single();

      if (insPay.error || !insPay.data) {
        return res.status(500).json({ error: `Insert paiement échoué: ${insPay.error?.message}` });
      }
      paymentId = insPay.data.id;
    }

    // 6) Upsert transaction rent (Finance)
    // Important: ton DB a un unique index partiel (user_id, receipt_id) where receipt_id is not null
    // => onConflict "user_id,receipt_id" marche si receipt_id non null.
    const occurredAt = String(receipt.period_end || receipt.period_start || "").slice(0, 10);
    const txPayload = [
      {
        user_id: userId,
        property_id: lease.property_id ?? null,
        lease_id: receipt.lease_id ?? null,
        receipt_id: receipt.id,
        occurred_at: occurredAt || String(receipt.issue_date || "").slice(0, 10) || new Date().toISOString().slice(0, 10),
        direction: "in",
        status: "received",
        category: "rent",
        label: "Loyer (quittance)",
        amount: Number(receipt.total_amount || 0),
        notes: null,
        updated_at: new Date().toISOString(),
      },
    ];

    const txUp = await supabaseAdmin.from("transactions").upsert(txPayload as any, { onConflict: "user_id,receipt_id" });
    if (txUp.error) {
      return res.status(500).json({ error: `Upsert transaction échoué: ${txUp.error.message}` });
    }

    // 7) Tenant email
    const tenantRes = await supabaseAdmin.from("tenants").select("*").eq("id", lease.tenant_id).single();
    const tenant: any = tenantRes.data || null;
    const toEmail = String(tenant?.email || "").trim();

    // Bailleur CC : priorité body, sinon lease.reminder_email, sinon null
    const ccEmail = landlordEmailFromBody || String(lease.reminder_email || "").trim() || null;

    // 8) Signed URL + download for attachment
    const signed = await supabaseAdmin.storage.from("rent-receipts-pdfs").createSignedUrl(parsed.path, 60 * 10);
    if (signed.error) return res.status(500).json({ error: `Signed URL échoué: ${signed.error.message}` });

    const yyyymm = String(receipt.period_start || "").slice(0, 7) || "quittance";
    const filename = `quittance-${yyyymm}.pdf`;

    let emailResult: { ok: boolean; id?: string | null; error?: string } = { ok: false, error: "Email non tenté." };

    // email only if tenant has email
    if (toEmail) {
      const pdfResp = await fetch(signed.data.signedUrl);
      if (!pdfResp.ok) {
        // on n'échoue pas tout: Finance a déjà été mise à jour, on log juste l'erreur
        emailResult = { ok: false, error: `Lecture PDF échouée (${pdfResp.status})` };
      } else {
        const pdfBuf = Buffer.from(await pdfResp.arrayBuffer());

        const subject = `Quittance de loyer – ${yyyymm}`;
        const html = `
          <div style="font-family:ui-sans-serif,system-ui,-apple-system;line-height:1.5">
            <p>Bonjour,</p>
            <p>Veuillez trouver en pièce jointe votre quittance de loyer pour <b>${yyyymm}</b>.</p>
            <p>Cordialement,<br/>ImmoPilot</p>
          </div>
        `;

        emailResult = await sendEmailViaResend({
          to: toEmail,
          cc: ccEmail,
          subject,
          html,
          attachments: [{ filename, contentBase64: base64(pdfBuf) }],
        });
      }
    } else {
      emailResult = { ok: false, error: "Le locataire n’a pas d’email (envoi ignoré)." };
    }

    // 9) Log email (non bloquant)
    try {
      await supabaseAdmin.from("email_logs").insert({
        user_id: userId,
        lease_id: receipt.lease_id,
        receipt_id: receipt.id,
        to_email: toEmail || null,
        cc_email: ccEmail,
        subject: `Quittance de loyer – ${yyyymm}`,
        body_preview: `Quittance ${yyyymm}`,
        status: emailResult.ok ? "sent" : "error",
        error_message: emailResult.ok ? null : emailResult.error,
        sent_at: new Date().toISOString(),
      });
    } catch {
      // ignore
    }

    // 10) Update rent_receipts
    // - status: "sent" seulement si email ok, sinon "confirmed"
    // - sent_at uniquement si email ok
    const newStatus = emailResult.ok ? "sent" : "confirmed";

    const upd = await supabaseAdmin
      .from("rent_receipts")
      .update({
        payment_id: paymentId,
        status: newStatus,
        sent_to_tenant_email: toEmail || receipt.sent_to_tenant_email || null,
        sent_at: emailResult.ok ? new Date().toISOString() : receipt.sent_at || null,
        send_error: emailResult.ok ? null : String(emailResult.error || "email_failed"),
        updated_at: new Date().toISOString(),
      })
      .eq("id", receipt.id);

    if (upd.error) return res.status(500).json({ error: `Update quittance échoué: ${upd.error.message}` });

    return res.status(200).json({
      ok: true,
      alreadyPaid,
      receipt_id: receipt.id,
      payment_id: paymentId,
      status: newStatus,
      email: {
        attempted: !!toEmail,
        ok: !!emailResult.ok,
        error: emailResult.ok ? null : emailResult.error,
        to: toEmail || null,
        cc: ccEmail,
      },
      signedUrl: signed.data.signedUrl,
    });
  } catch (e: any) {
    console.error("[api/receipts/confirm-manual] error:", e);
    return res.status(500).json({ error: e?.message || "Erreur interne" });
  }
}
