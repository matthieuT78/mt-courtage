import type { NextApiRequest, NextApiResponse } from "next";
import PDFDocument from "pdfkit";
import { supabaseAdmin } from "../../../lib/supabaseAdmin";

type Json = Record<string, any>;

const toISODate = (d: Date) => d.toISOString().slice(0, 10);

const fmtDateTimeFR = (iso?: string | null) => {
  if (!iso) return "—";
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return String(iso);
  return d.toLocaleString("fr-FR", {
    year: "numeric",
    month: "long",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
};

const safeText = (s: any) => (s == null ? "" : String(s));

function collectDefects(item: any) {
  const tags = Array.isArray(item?.defect_tags) ? item.defect_tags : [];
  return tags.length ? tags.join(", ") : "";
}

function conditionLabel(c: string) {
  switch (c) {
    case "neuf":
      return "Neuf";
    case "tres_bon":
      return "Très bon";
    case "bon":
      return "Bon";
    case "moyen":
      return "Moyen";
    case "mauvais":
      return "Mauvais";
    default:
      return c || "—";
  }
}

function yn(v: any) {
  if (v === true) return "Oui";
  if (v === false) return "Non";
  return "—";
}

function buildPdfBuffer(build: (doc: PDFKit.PDFDocument) => Promise<void>) {
  return new Promise<Buffer>(async (resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: "A4",
        margin: 46,
        bufferPages: true, // ✅ pour pagination
      });

      const chunks: Buffer[] = [];
      doc.on("data", (c) => chunks.push(c));
      doc.on("end", () => resolve(Buffer.concat(chunks)));

      await build(doc);

      // ✅ Pagination après génération
      const range = doc.bufferedPageRange(); // { start, count }
      for (let i = range.start; i < range.start + range.count; i++) {
        doc.switchToPage(i);

        const pageNumber = i - range.start + 1;
        const total = range.count;

        doc.font("Helvetica").fontSize(9);
        doc.fillColor("#666666");
        doc.text(
          `Page ${pageNumber} / ${total}`,
          doc.page.margins.left,
          doc.page.height - doc.page.margins.bottom + 16,
          { align: "center", width: doc.page.width - doc.page.margins.left - doc.page.margins.right }
        );
      }

      doc.end();
    } catch (e) {
      reject(e);
    }
  });
}

function ensureSpace(doc: PDFKit.PDFDocument, needed = 120) {
  if (doc.y + needed > doc.page.height - doc.page.margins.bottom - 20) doc.addPage();
}

function drawSectionTitle(doc: PDFKit.PDFDocument, title: string) {
  ensureSpace(doc, 60);
  doc.moveDown(0.3);
  doc.font("Helvetica-Bold").fontSize(12).fillColor("#111111").text(title);
  doc.moveDown(0.2);
  doc.moveTo(doc.page.margins.left, doc.y)
    .lineTo(doc.page.width - doc.page.margins.right, doc.y)
    .strokeColor("#e5e7eb")
    .stroke();
  doc.moveDown(0.6);
}

function drawKeyValueRow(doc: PDFKit.PDFDocument, label: string, value: string) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  doc.font("Helvetica-Bold").fontSize(10).fillColor("#111").text(label, x, doc.y, { width: 120 });
  doc.font("Helvetica").fontSize(10).fillColor("#111").text(value || "—", x + 125, doc.y, { width: w - 125 });
  doc.moveDown(0.25);
}

function drawHeader(doc: PDFKit.PDFDocument, title: string, subtitle: string) {
  const x = doc.page.margins.left;
  const y = doc.page.margins.top - 20;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  // Bandeau
  doc.save();
  doc.rect(x, y, w, 56).fill("#0f172a"); // slate-900
  doc.restore();

  doc.fillColor("#ffffff");
  doc.font("Helvetica-Bold").fontSize(16).text(title, x + 16, y + 12, { width: w - 32 });
  doc.font("Helvetica").fontSize(10).text(subtitle, x + 16, y + 34, { width: w - 32 });

  doc.moveDown(1.8);
  doc.fillColor("#111111");
}

function tableHeader(doc: PDFKit.PDFDocument) {
  const x = doc.page.margins.left;
  const y = doc.y;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  // Header row background
  doc.save();
  doc.rect(x, y, w, 18).fill("#f1f5f9"); // slate-100
  doc.restore();

  doc.font("Helvetica-Bold").fontSize(9).fillColor("#111");
  doc.text("Catégorie", x + 6, y + 5, { width: 80 });
  doc.text("Élément", x + 92, y + 5, { width: 150 });
  doc.text("État", x + 248, y + 5, { width: 70 });
  doc.text("Propre", x + 322, y + 5, { width: 50 });
  doc.text("Fonct.", x + 375, y + 5, { width: 50 });
  doc.text("Observations", x + 430, y + 5, { width: w - 430 });

  doc.moveDown(1.2);
  doc.moveTo(x, doc.y).lineTo(x + w, doc.y).strokeColor("#e5e7eb").stroke();
  doc.moveDown(0.3);
}

function tableRow(doc: PDFKit.PDFDocument, row: { cat: string; label: string; cond: string; clean: string; func: string; obs: string }, stripe: boolean) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  // hauteur dynamique selon obs
  const startY = doc.y;
  const obsHeight = doc.heightOfString(row.obs || "—", { width: w - 430, align: "left" });
  const rowH = Math.max(16, Math.min(120, obsHeight + 10));

  ensureSpace(doc, rowH + 24);

  // stripe
  if (stripe) {
    doc.save();
    doc.rect(x, startY, w, rowH).fill("#fcfcfd");
    doc.restore();
  }

  doc.font("Helvetica").fontSize(9).fillColor("#111");
  doc.text(row.cat || "—", x + 6, startY + 4, { width: 80 });
  doc.text(row.label || "—", x + 92, startY + 4, { width: 150 });
  doc.text(row.cond || "—", x + 248, startY + 4, { width: 70 });
  doc.text(row.clean || "—", x + 322, startY + 4, { width: 50 });
  doc.text(row.func || "—", x + 375, startY + 4, { width: 50 });
  doc.text(row.obs || "—", x + 430, startY + 4, { width: w - 430 });

  doc.y = startY + rowH;
  doc.moveTo(x, doc.y).lineTo(x + w, doc.y).strokeColor("#f1f5f9").stroke();
  doc.moveDown(0.2);
}

export default async function handler(req: NextApiRequest, res: NextApiResponse<Json>) {
  try {
    if (req.method !== "POST") return res.status(405).json({ error: "Method not allowed" });
    if (!supabaseAdmin) return res.status(500).json({ error: "Supabase admin non configuré (env manquantes)." });

    const { reportId, userId } = (req.body || {}) as { reportId?: string; userId?: string };
    if (!reportId || !userId) return res.status(400).json({ error: "reportId et userId requis." });

    // 1) report + contrôle ownership
    const { data: report, error: repErr } = await supabaseAdmin
      .from("inventory_reports")
      .select("*")
      .eq("id", reportId)
      .single();

    if (repErr || !report) return res.status(404).json({ error: "Report introuvable." });
    if (report.user_id !== userId) return res.status(403).json({ error: "Accès refusé." });

    // 2) rooms/items/photos + infos bail / property / tenant / landlord
    const [{ data: rooms, error: rRoomsErr }, { data: items, error: rItemsErr }, { data: photos, error: rPhotosErr }] =
      await Promise.all([
        supabaseAdmin.from("inventory_rooms").select("*").eq("report_id", reportId).order("sort_order", { ascending: true }),
        supabaseAdmin.from("inventory_items").select("*").eq("report_id", reportId).order("created_at", { ascending: true }),
        // si la table n'existe pas chez toi, laisse cette requête mais gère en "null"
        supabaseAdmin.from("inventory_photos").select("*").eq("report_id", reportId).order("created_at", { ascending: true }),
      ]);

    if (rRoomsErr) return res.status(500).json({ error: `rooms: ${rRoomsErr.message}` });
    if (rItemsErr) return res.status(500).json({ error: `items: ${rItemsErr.message}` });
    // photos peut être optionnel selon ton schéma
    const safePhotos = rPhotosErr ? [] : (photos || []);

    const { data: lease } = await supabaseAdmin.from("leases").select("*").eq("id", report.lease_id).single();

    let property: any = null;
    let tenant: any = null;
    let landlord: any = null;

    if (lease?.property_id) {
      const r = await supabaseAdmin.from("properties").select("*").eq("id", lease.property_id).single();
      property = r.data || null;
    }
    if (lease?.tenant_id) {
      const r = await supabaseAdmin.from("tenants").select("*").eq("id", lease.tenant_id).single();
      tenant = r.data || null;
    }
    const rLand = await supabaseAdmin.from("landlords").select("*").eq("user_id", userId).single();
    landlord = rLand.data || null;

    // 3) photos par item
    const photosByItem = new Map<string, any[]>();
    for (const p of safePhotos as any[]) {
      if (!p?.item_id) continue;
      const arr = photosByItem.get(p.item_id) || [];
      arr.push(p);
      photosByItem.set(p.item_id, arr);
    }

    // 4) PDF
    const title = report.report_type === "entry" ? "ÉTAT DES LIEUX D’ENTRÉE" : "ÉTAT DES LIEUX DE SORTIE";

    const landlordName = landlord?.display_name || "Bailleur";
    const tenantName = tenant?.full_name || "Locataire";
    const propLabel = property?.label || "Bien";
    const propAddr = [
      property?.address_line1,
      property?.address_line2,
      [property?.postal_code, property?.city].filter(Boolean).join(" "),
      property?.country,
    ]
      .filter(Boolean)
      .join(", ");

    const pdf = await buildPdfBuffer(async (doc) => {
      drawHeader(
        doc,
        title,
        `Généré le ${new Date().toLocaleDateString("fr-FR")} — ImmoPilot`
      );

      drawSectionTitle(doc, "Informations");
      drawKeyValueRow(doc, "Bailleur", landlordName);
      drawKeyValueRow(doc, "Locataire", tenantName);
      drawKeyValueRow(doc, "Bien", `${propLabel}${propAddr ? " — " + propAddr : ""}`);
      drawKeyValueRow(doc, "Date", fmtDateTimeFR(report.performed_at));
      drawKeyValueRow(doc, "Lieu", safeText(report.performed_place) || "—");

      if (report.general_notes) {
        doc.moveDown(0.2);
        doc.font("Helvetica-Bold").fontSize(10).text("Notes générales");
        doc.font("Helvetica").fontSize(10).fillColor("#111").text(safeText(report.general_notes));
      }

      // Compteurs
      if (report.counters_json && Object.keys(report.counters_json || {}).length) {
        drawSectionTitle(doc, "Compteurs");
        const c = report.counters_json || {};
        for (const k of Object.keys(c)) {
          const v = c[k];
          if (v && typeof v === "object") {
            doc.font("Helvetica-Bold").fontSize(10).text(`${k} : `, { continued: true });
            doc.font("Helvetica").fontSize(10).text(
              `${safeText(v.index)} ${safeText(v.unit)}${v.note ? " — " + safeText(v.note) : ""}`
            );
          } else {
            doc.font("Helvetica-Bold").fontSize(10).text(`${k} : `, { continued: true });
            doc.font("Helvetica").fontSize(10).text(`${safeText(v)}`);
          }
        }
      }

      drawSectionTitle(doc, "Détail par pièce");

      const roomList = (rooms || []) as any[];
      const itemList = (items || []) as any[];

      const itemsByRoom = new Map<string, any[]>();
      for (const it of itemList) {
        const rid = it.room_id || "__no_room__";
        const arr = itemsByRoom.get(rid) || [];
        arr.push(it);
        itemsByRoom.set(rid, arr);
      }

      for (const room of roomList) {
        ensureSpace(doc, 160);

        doc.font("Helvetica-Bold").fontSize(12).fillColor("#111").text(
          `${room.name}${room.floor_level ? " — " + room.floor_level : ""}`
        );
        if (room.notes) {
          doc.font("Helvetica").fontSize(10).fillColor("#444").text(`Notes : ${room.notes}`);
        }
        doc.moveDown(0.2);

        tableHeader(doc);

        const rItems = itemsByRoom.get(room.id) || [];
        if (!rItems.length) {
          doc.font("Helvetica").fontSize(10).fillColor("#666").text("Aucun élément renseigné.");
          doc.moveDown(0.8);
          continue;
        }

        let stripe = false;
        for (const it of rItems) {
          const defects = collectDefects(it);
          const desc = safeText(it.description);
          const obs = [desc, defects ? `Défauts: ${defects}` : ""].filter(Boolean).join(" • ");

          tableRow(
            doc,
            {
              cat: safeText(it.category),
              label: safeText(it.label),
              cond: conditionLabel(it.condition),
              clean: yn(it.is_clean),
              func: yn(it.is_functional),
              obs: obs || "—",
            },
            stripe
          );
          stripe = !stripe;

          // Miniatures (max 2) – optionnel, et sans casser si une image foire
          const pList = (photosByItem.get(it.id) || []).slice(0, 2);
          if (pList.length) {
            ensureSpace(doc, 110);
            const startY = doc.y + 4;
            let x = doc.page.margins.left;

            for (const p of pList) {
              const bucket = p.storage_bucket || "inventory-photos";
              const path = p.storage_path;
              if (!path) continue;

              const { data: imgData } = await supabaseAdmin!.storage.from(bucket).download(path);
              if (!imgData) continue;

              try {
                const buf = Buffer.from(await imgData.arrayBuffer());
                doc.save();
                doc.rect(x, startY, 120, 86).strokeColor("#e5e7eb").stroke();
                doc.image(buf, x + 4, startY + 4, { fit: [112, 78] });
                doc.restore();
                x += 130;
              } catch {
                // ignore
              }
            }

            doc.y = startY + 92;
            doc.moveDown(0.4);
          }
        }

        doc.moveDown(0.8);
      }

      // Items hors pièce
      const noRoomItems = itemsByRoom.get("__no_room__") || [];
      if (noRoomItems.length) {
        doc.addPage();
        drawSectionTitle(doc, "Éléments hors pièce");
        tableHeader(doc);

        let stripe = false;
        for (const it of noRoomItems) {
          const defects = collectDefects(it);
          const desc = safeText(it.description);
          const obs = [desc, defects ? `Défauts: ${defects}` : ""].filter(Boolean).join(" • ");

          tableRow(
            doc,
            {
              cat: safeText(it.category),
              label: safeText(it.label),
              cond: conditionLabel(it.condition),
              clean: yn(it.is_clean),
              func: yn(it.is_functional),
              obs: obs || "—",
            },
            stripe
          );
          stripe = !stripe;
        }
      }

      // Signatures
      doc.addPage();
      drawSectionTitle(doc, "Signatures");

      doc.font("Helvetica").fontSize(10).fillColor("#111");
      doc.text("Bailleur :", { continued: false });
      doc.moveDown(0.8);
      doc.rect(doc.page.margins.left, doc.y, 240, 90).strokeColor("#e5e7eb").stroke();
      doc.moveDown(6);

      doc.text("Locataire :", { continued: false });
      doc.moveDown(0.8);
      doc.rect(doc.page.margins.left, doc.y, 240, 90).strokeColor("#e5e7eb").stroke();
      doc.moveDown(1);
    });

    // 5) Upload PDF vers Storage
    const filename = `etat-des-lieux-${report.report_type}-${toISODate(new Date())}.pdf`;
    const storagePath = `${userId}/${report.lease_id}/${reportId}/${filename}`;

    const { error: upErr } = await supabaseAdmin.storage
      .from("inventory-pdfs")
      .upload(storagePath, pdf, { contentType: "application/pdf", upsert: true });

    if (upErr) return res.status(500).json({ error: `Upload PDF échoué: ${upErr.message}` });

    // 6) Update report
    const pdfUrl = `inventory-pdfs:${storagePath}`;

    const { error: updErr } = await supabaseAdmin
      .from("inventory_reports")
      .update({ pdf_url: pdfUrl, updated_at: new Date().toISOString() })
      .eq("id", reportId);

    if (updErr) return res.status(500).json({ error: `Update report échoué: ${updErr.message}` });

    return res.status(200).json({ ok: true, pdf_url: pdfUrl, storage_path: storagePath });
  } catch (e: any) {
    console.error("[api/inventory/pdf] error:", e);
    return res.status(500).json({ error: e?.message || "Erreur interne" });
  }
}
